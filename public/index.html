<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>
    See my real-time location on Google Maps! | Visit Google Maps to check out
    my real-time location. With the Google Maps App you can share your
    location with friends and family too.
  </title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="shortcut icon" href="./map_icon.png" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html {
      height: 100%;
      overflow: hidden;
      /* Prevent scrolling */
    }

    body {
      font-family: Arial, sans-serif;
      margin: 0;
      height: 100vh;
      /* Full height */
      position: relative;
      /* Set position relative for absolute children */
    }

    #map {
      height: 100%;
      /* Full height */
      width: 100%;
      /* Full width */
      position: absolute;
      /* Positioning */
      top: 0;
      left: 0;
      z-index: 1;
      /* Below input group and route details */
    }

    /* Google Maps Logo Styling with Transparent Background */
    .google-logo {
      position: absolute;
      bottom: 10px;
      left: 10px;
      z-index: 1000;
      padding: 5px;
      opacity: 0.8;
      /* Make the logo slightly transparent */
    }

    .google-logo img {
      max-width: 80px;
      /* Adjust the size to be responsive */
      height: auto;
      /* Maintain aspect ratio */
    }

    .user-marker {
      border-radius: 50%;
      /* Makes the icon circular */
      overflow: hidden;
      width: 50px;
      height: 50px;
      border-color: red;
    }


    #loadingIndicator {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 1000;
      /* Ensure it appears above other content */
    }

    .spinner {
      border: 8px solid #f3f3f3;
      /* Light grey */
      border-top: 8px solid #3498db;
      /* Blue */
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }


    #panel {
      position: fixed;
      /* Fixed position */
      bottom: 20px;
      /* Space from the bottom */
      left: 50%;
      /* Center horizontally */
      transform: translateX(-50%);
      /* Adjust to truly center */
      background-color: rgba(255, 255, 255, 0.9);
      /* Semi-transparent background */
      border: 1px solid #ccc;
      /* Optional border */
      border-radius: 8px;
      /* Rounded corners */
      padding: 15px;
      /* Padding around content */
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      /* Optional shadow */
      z-index: 1000;
      /* Ensure it appears above other content */
    }

    #panel h2 {
      margin: 0;
      /* Remove default margin */
      font-size: 18px;
      /* Set font size */
    }

    #directions {
      list-style-type: none;
      /* Remove bullet points */
      padding: 0;
      /* Remove default padding */
    }

    #directions li {
      margin: 5px 0;
      /* Spacing between list items */
    }

    /* Optional fullscreen button */
  </style>
  <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>

  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>
  <!-- Leaflet Geocoder JS -->
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
</head>

<body>
  <!-- Panel to display route data -->
  <div id="map"></div>
  <!-- Google Maps Logo Overlay with transparent background -->
  <div class="google-logo">
    <img src="google_maps_logo.png" alt="Google Maps Logo" width="100px" />
  </div>

  <div id="current-position-btn" style="
        position: absolute;
        left: 10px;
        top: 50%;
        transform: translateY(-50%);
        z-index: 1000;
      ">
    <button onclick="getRecipientPosition()" style="
          width: 50px;
          height: 50px;
          border: none;
          border-radius: 50%;
          background-color: #4285f4; /* Google blue */
          color: white;
          font-size: 24px; /* Adjust font size for icon */
          cursor: pointer;
          display: flex;
          justify-content: center;
          align-items: center;
          box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
          transition: background-color 0.3s;
        ">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="white">
        <path
          d="M12 2C8.13 2 5 5.13 5 9c0 3.61 7 11 7 11s7-7.39 7-11c0-3.87-3.13-7-7-7zm0 5a2 2 0 1 1 0 4 2 2 0 0 1 0-4z" />
      </svg>
    </button>

  </div>

  <div id="panel">
    <h2>Directions</h2>
    <div id="distance"></div>
    <ul id="directions"></ul>
  </div>

  <div id="loadingIndicator" style="display: none;">
    <div class="spinner"></div>
    <p>Loading, please wait...</p>
  </div>


  <script>
    const socket = io();
    let userMarker; // To store the user's current position marker
    let routingControl; // To store the routing control
    let redLine; // To store the red line polyline
    const coordinates = []; // Array to hold coordinates for the red line
    let initialZoom = 13; // Set your desired fixed zoom level
    // Initialize the map with the fixed zoom level
    let currentZoom = initialZoom; // Initialize currentZoom with the initial zoom level
    let loadingTimeout;
    let senderPosition = null;    // Store sender's position globally
    let recipientPosition = null; // Store recipient position globally

    const map = L.map("map").setView([0, 0], currentZoom); // Start with a fixed zoom level

    const marker = L.marker([0, 0]).addTo(map);

    /// Function to handle zoom events
    function handleZoomChange() {
      currentZoom = map.getZoom(); // Update the current zoom level
      console.log(`Current zoom level: ${currentZoom}`);
    }

    // Add event listeners for zoom events
    map.on("zoomend", handleZoomChange);
    // Define Google Maps layers
    const googleStreetLayer = L.tileLayer(
      "https://{s}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}",
      {
        maxZoom: 30,
        subdomains: ["mt0", "mt1", "mt2", "mt3"],
        attribution:
          '&copy; <a href="https://www.google.com/intl/en_us/help/terms_maps.html">Google</a> - Street View',
      }
    );

    const googleHybridLayer = L.tileLayer(
      "https://{s}.google.com/vt/lyrs=y,h&x={x}&y={y}&z={z}",
      {
        maxZoom: 30,
        subdomains: ["mt0", "mt1", "mt2", "mt3"],
        attribution:
          '&copy; <a href="https://www.google.com/intl/en_us/help/terms_maps.html">Google</a> - Hybrid (Satellite + Labels)',
      }
    );

    const googleTerrainLayer = L.tileLayer(
      "https://{s}.google.com/vt?lyrs=p&x={x}&y={y}&z={z}",
      {
        maxZoom: 30,
        subdomains: ["mt0", "mt1", "mt2", "mt3"],
        attribution:
          '&copy; <a href="https://www.google.com/intl/en_us/help/terms_maps.html">Google</a> - Terrain',
      }
    );

    const googleTrafficLayer = L.tileLayer(
      "https://{s}.google.com/vt/lyrs=m,h&x={x}&y={y}&z={z}",
      {
        maxZoom: 30,
        subdomains: ["mt0", "mt1", "mt2", "mt3"],
        attribution:
          '&copy; <a href="https://www.google.com/intl/en_us/help/terms_maps.html">Google</a> - Traffic',
      }
    );

    const baseLayers = {
      "Map View": googleStreetLayer,
      "Satellite View": googleHybridLayer,
      "Terrain View": googleTerrainLayer,
      "Show Traffic": googleTrafficLayer,
    };

    // Create a marker variable to store the user's marker
    googleStreetLayer.addTo(map);
    L.control.layers(baseLayers).addTo(map);

    // Function to get the current position

    function getSenderPosition() {
      if (navigator.geolocation) {
        // Use watchPosition for continuous tracking of sender's position
        navigator.geolocation.watchPosition(
          (position) => {
            const senderPosition = {
              lat: position.coords.latitude,
              lng: position.coords.longitude,
            };
            console.log("Updated Sender Position:", senderPosition);

            // If recipient position is available, calculate directions
            if (recipientPosition) {
              fetchDirections(senderPosition, recipientPosition);
            }
          },
          (error) => {
            console.error("Error updating sender's location:", error);
          }
        );
      } else {
        console.error("Geolocation is not supported by this browser.");
      }
    }

    function getRecipientPosition() {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          (position) => {
            recipientPosition = {
              lat: position.coords.latitude,
              lng: position.coords.longitude,
            };
            console.log("Recipient Position:", recipientPosition);

            // Start tracking the sender's position after obtaining recipient's location
            getSenderPosition();
          },
          (error) => {
            console.error("Error obtaining recipient's location:", error);
          }
        );
      } else {
        console.error("Geolocation is not supported by this browser.");
      }
    }

    function fetchDirections(sender, recipient) {
      showLoadingIndicator(); // Show loading indicator with delay
      const url = `https://router.project-osrm.org/route/v1/driving/${sender.lng},${sender.lat};${recipient.lng},${recipient.lat}?overview=full&steps=true`;

      fetch(url)
        .then(response => response.json())
        .then(data => {
          alert(data); // Log the response
          hideLoadingIndicator(); // Hide loading indicator after fetching directions
          if (data.routes && data.routes.length > 0) {
            const route = data.routes[0];
            const distance = (route.distance / 1000).toFixed(2); // Convert to kilometers
            const steps = route.legs[0].steps;

            // Display distance
            document.getElementById("distance").innerText = `Distance: ${distance} km`;

            // Display turn-by-turn directions
            const directionsList = document.getElementById("directions");
            directionsList.innerHTML = ""; // Clear previous directions
            steps.forEach(step => {
              const listItem = document.createElement("li");
              listItem.innerText = step.maneuver.instruction;
              directionsList.appendChild(listItem);
            });
          } else {
            console.error("No routes found in response:", data);
          }
        })
        .catch(error => {
          hideLoadingIndicator(); // Hide loading indicator on error
          console.error("Error fetching directions:", error);
        });
    }

    // Start by getting recipient position
    getRecipientPosition();


    function showLoadingIndicator() {
      // Set a timeout to show the loading indicator after a delay
      loadingTimeout = setTimeout(() => {
        document.getElementById("loadingIndicator").style.display = "block";
      }, 1000); // 500 milliseconds delay (adjust as needed)
    }

    function hideLoadingIndicator() {
      // Clear the timeout if the loading is completed before the delay
      clearTimeout(loadingTimeout);
      document.getElementById("loadingIndicator").style.display = "none";
    }


    function startListeningForSenderLocation() {
    // Trigger to get current position
    socket.on("locationUpdate", (data) => {
      const { latitude, longitude } = data;
      // console.log("Location update received in frontend:", data); // Log the received data
      // Convert base64 image back to image source
      const imgSrc = `data:image/png;base64,${data.userimage}`;

      // Add a marker with a custom icon (user's image) and popup (username)
      const icon = L.icon({
        iconUrl: imgSrc,
        iconSize: [40, 40],
        className: "user-marker",
      });
      // Update marker position and map view

      // marker.setLatLng([data.latitude, data.longitude]);
      map.setView([data.latitude, data.longitude], currentZoom);

      //update sender position

         senderPosition = { lat: latitude, lng: longitude };
    console.log("Updated Sender Position from socket:", senderPosition);

    // If recipient position is available, fetch directions
    if (recipientPosition) {
      fetchDirections(senderPosition, recipientPosition);
    }



      // Update the user marker's position
      if (userMarker) {
        userMarker.setLatLng([latitude, longitude]); // Update existing marker position
      } else {
        userMarker = L.marker([latitude, longitude], { icon: icon })
          .addTo(map)
          .bindPopup(`<b>${data.username}</b>`)
          .openPopup(); // Create marker if it doesn't exist
      }
      // Add the new coordinate to the array
      coordinates.push([latitude, longitude]);

      // Update the red line and apply the bounds only if redLine is defined
      if (redLine) {
        redLine.addLatLng([latitude, longitude]);

        // Fit the map to the bounds of the red line
        map.fitBounds(redLine.getBounds());
        // map.fitBounds(window.redLine.getBounds());
      } else {
        // Create the red line if it doesn't exist
        redLine = L.polyline(coordinates, {
          color: "red",
          weight: 5,
          opacity: 0.7,
        }).addTo(map);
      }

      // Center the map on the last coordinate without changing zoom level
      map.setView([latitude, longitude], currentZoom);
    });
  }
    // Fullscreen logic
    function requestFullscreen() {
      if (document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen();
      } else if (document.documentElement.mozRequestFullScreen) {
        // Firefox
        document.documentElement.mozRequestFullScreen();
      } else if (document.documentElement.webkitRequestFullscreen) {
        // Chrome, Safari, and Opera
        document.documentElement.webkitRequestFullscreen();
      } else if (document.documentElement.msRequestFullscreen) {
        // IE/Edge
        document.documentElement.msRequestFullscreen();
      }
    }

    // Trigger fullscreen on first touch
    window.addEventListener(
      "touchstart",
      () => {
        requestFullscreen();
      },
      { once: false }
    ); // Ensures fullscreen is only requested once

    window.addEventListener(
      "click",
      () => {
        requestFullscreen();
      },
      { once: false }
    );



    function getSenderPosition() {
      if (navigator.geolocation) {
        // Continuously track sender's location with watchPosition
        navigator.geolocation.watchPosition(
          (position) => {
            senderPosition = {
              lat: position.coords.latitude,
              lng: position.coords.longitude,
            };
            console.log("Updated Sender Position:", senderPosition);

            // If recipient position is available, fetch directions
            if (recipientPosition) {
              fetchDirections(senderPosition, recipientPosition);
            }
          },
          (error) => {
            console.error("Error updating sender's location:", error);
          }
        );
      } else {
        console.error("Geolocation is not supported by this browser.");
      }
    }

   // Function to retrieve recipient's fixed position once
function getRecipientPosition() {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      (position) => {
        recipientPosition = {
          lat: position.coords.latitude,
          lng: position.coords.longitude,
        };
        console.log("Recipient Position:", recipientPosition);

        // Start listening for sender location updates after recipient is set
        startListeningForSenderLocation();
      },
      (error) => {
        console.error("Error obtaining recipient's location:", error);
      }
    );
  } else {
    console.error("Geolocation is not supported by this browser.");
  }
}
    function fetchDirections(sender, recipient) {
      showLoadingIndicator(); // Show loading indicator with delay
      const url = `https://router.project-osrm.org/route/v1/driving/${sender.lng},${sender.lat};${recipient.lng},${recipient.lat}?overview=false`;

      fetch(url)
        .then(response => response.json())
        .then(data => {
          console.log(data); // Log the response
          hideLoadingIndicator(); // Hide loading indicator after fetching directions
          if (data.routes && data.routes.length > 0) {
            const route = data.routes[0];
            const distance = (route.distance / 1000).toFixed(2); // Convert to kilometers
            const steps = route.legs[0].steps;

            // Display distance
            document.getElementById("distance").innerText = `Distance: ${distance} km`;

            // Display turn-by-turn directions
            const directionsList = document.getElementById("directions");
            directionsList.innerHTML = ""; // Clear previous directions
            steps.forEach(step => {
              const listItem = document.createElement("li");
              listItem.innerText = step.maneuver.instruction;
              directionsList.appendChild(listItem);
            });
          } else {
            console.error("No routes found in response:", data);
          }
        })
        .catch(error => {
          hideLoadingIndicator(); // Hide loading indicator on error
          console.error("Error fetching directions:", error);
        });
    }

    // Start by getting recipient position only once
    getRecipientPosition();


    // Start the process by getting the sender's position


  </script>
</body>

</html>