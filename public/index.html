<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>
    See my real-time location on Google Maps! | Visit Google Maps to check out
    my real-time location. With the Google Maps App you can share your
    location with friends and family too.
  </title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="shortcut icon" href="./map_icon.png" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }


    html {
      height: 100%;
      overflow: hidden;
      /* Prevent scrolling */
    }

    body {
      font-family: Arial, sans-serif;
      margin: 0;
      height: 100vh;
      /* Full height */
      position: relative;
      /* Set position relative for absolute children */
    }

    #map {
      height: 100%;
      /* Full height */
      width: 100%;
      /* Full width */
      position: absolute;
      /* Positioning */
      top: 0;
      left: 0;
      z-index: 1;
      /* Below input group and route details */
    }

    /* Google Maps Logo Styling with Transparent Background */
    .google-logo {
      position: absolute;
      bottom: 10px;
      left: 10px;
      z-index: 1000;
      padding: 5px;
      opacity: 0.8;
      /* Make the logo slightly transparent */
    }

    .google-logo img {
      max-width: 80px;
      /* Adjust the size to be responsive */
      height: auto;
      /* Maintain aspect ratio */
    }

    .user-marker {
      border-radius: 50%;
      /* Makes the icon circular */
      overflow: hidden;
      width: 50px;
      height: 50px;
      border-color: red;
    }

    #routeDetails {
      border: 1px solid #ccc;
      padding: 10px;
      background-color: rgba(249, 249, 249, 0.8);
      /* Light background */
      width: 90%;
      /* Width of the route details */
      max-width: 400px;
      /* Maximum width */
      text-align: center;
      /* Center text */
      margin-bottom: 10px;
      /* Space from the button */
      z-index: 10;
      /* Higher than the map */
      position: fixed;
      /* Fixed positioning */
      bottom: 80px;
      /* Distance from the bottom */
      left: 50%;
      transform: translateX(-50%);
      /* Center it horizontally */
    }

    button {
      position: fixed;
      /* Make it fixed to the viewport */
      bottom: 20px;
      /* Distance from the bottom */
      right: 20px;
      /* Distance from the right */
      padding: 10px 15px;
      background-color: #007BFF;
      /* Blue color */
      color: white;
      /* Text color */
      border: none;
      /* No border */
      border-radius: 5px;
      /* Rounded corners */
      cursor: pointer;
      /* Pointer cursor */
      z-index: 1000;
      /* Ensure it stays above other elements */
    }

    button:hover {
      background-color: #0056b3;
      /* Darker blue on hover */
    }

    /* Optional fullscreen button */
  </style>
  <script src="./leaflet.js"></script>
  <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>

  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>
  <!-- Leaflet Geocoder JS -->
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
</head>

<body>

  <!-- Panel to display route data -->
  <div id="routeDetails"></div>

  <button id="showRouteButton" onclick="fetchRouteData()" style="display: none;">Show Route</button>
  <div id="map"></div>
  <!-- Google Maps Logo Overlay with transparent background -->
  <div class="google-logo">
    <img src="google_maps_logo.png" alt="Google Maps Logo" width="100px" />
  </div>

  <div id="current-position-btn" style="
        position: absolute;
        left: 10px;
        top: 50%;
        transform: translateY(-50%);
        z-index: 1000;
      ">
    <button onclick="getCurrentPosition()" style="
          width: 50px;
          height: 50px;
          border: none;
          border-radius: 50%;
          background-color: #4285f4; /* Google blue */
          color: white;
          font-size: 24px; /* Adjust font size for icon */
          cursor: pointer;
          display: flex;
          justify-content: center;
          align-items: center;
          box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
          transition: background-color 0.3s;
        ">

      <!-- You can use an icon here -->
    </button>
  </div>

  <script>
    const socket = io();
    let userMarker; // To store the user's current position marker
    let routingControl; // To store the routing control
    let redLine; // To store the red line polyline
    const coordinates = []; // Array to hold coordinates for the red line
    let initialZoom = 13; // Set your desired fixed zoom level
    // Initialize the map with the fixed zoom level
    let currentZoom = initialZoom; // Initialize currentZoom with the initial zoom level
    let startPoint, endPoint;

    const map = L.map("map").setView([0, 0], currentZoom); // Start with a fixed zoom level

    const marker = L.marker([0, 0]).addTo(map);

    /// Function to handle zoom events
    function handleZoomChange() {
      currentZoom = map.getZoom(); // Update the current zoom level
      console.log(`Current zoom level: ${currentZoom}`);
    }

    // Add event listeners for zoom events
    map.on("zoomend", handleZoomChange);
    // Define Google Maps layers
    const googleStreetLayer = L.tileLayer(
      "https://{s}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}",
      {
        maxZoom: 30,
        subdomains: ["mt0", "mt1", "mt2", "mt3"],
        attribution:
          '&copy; <a href="https://www.google.com/intl/en_us/help/terms_maps.html">Google</a> - Street View',
      }
    );

    const googleHybridLayer = L.tileLayer(
      "https://{s}.google.com/vt/lyrs=y,h&x={x}&y={y}&z={z}",
      {
        maxZoom: 30,
        subdomains: ["mt0", "mt1", "mt2", "mt3"],
        attribution:
          '&copy; <a href="https://www.google.com/intl/en_us/help/terms_maps.html">Google</a> - Hybrid (Satellite + Labels)',
      }
    );

    const googleTerrainLayer = L.tileLayer(
      "https://{s}.google.com/vt?lyrs=p&x={x}&y={y}&z={z}",
      {
        maxZoom: 30,
        subdomains: ["mt0", "mt1", "mt2", "mt3"],
        attribution:
          '&copy; <a href="https://www.google.com/intl/en_us/help/terms_maps.html">Google</a> - Terrain',
      }
    );

    const googleTrafficLayer = L.tileLayer(
      "https://{s}.google.com/vt/lyrs=m,h&x={x}&y={y}&z={z}",
      {
        maxZoom: 30,
        subdomains: ["mt0", "mt1", "mt2", "mt3"],
        attribution:
          '&copy; <a href="https://www.google.com/intl/en_us/help/terms_maps.html">Google</a> - Traffic',
      }
    );

    const baseLayers = {
      "Map View": googleStreetLayer,
      "Satellite View": googleHybridLayer,
      "Terrain View": googleTerrainLayer,
      "Show Traffic": googleTrafficLayer,
    };

    // Create a marker variable to store the user's marker
    googleStreetLayer.addTo(map);
    L.control.layers(baseLayers).addTo(map);
    // Create a marker

    // Function to get the current position
    function getCurrentPosition() {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          (position) => {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;

            // Set view to current position with fixed zoom
            map.setView([lat, lng], currentZoom);

            // Add or update user marker
            if (userMarker) {
              userMarker.setLatLng([lat, lng]);
            } else {
              userMarker = L.marker([lat, lng])
                .addTo(map)
                .bindPopup("You are here!")
                .openPopup();
            }
          },
          (error) => {
            console.error("Error obtaining location:", error);
          }
        );
      } else {
        console.error("Geolocation is not supported by this browser.");
      }
    }

    // Function to set up and calculate the route
    function calculateRoute() {
      if (routingControl) {
        map.removeControl(routingControl); // Remove existing route if any
      }

      // Proceed only if both start and end points are set
      if (startPoint && endPoint) {
        routingControl = L.Routing.control({
          waypoints: [L.latLng(startPoint.lat, startPoint.lng), L.latLng(endPoint.lat, endPoint.lng)],
          routeWhileDragging: true,
          geocoder: L.Control.Geocoder.nominatim(),
        })
          .on("routesfound", function (e) {
            const route = e.routes[0];
            const routeInstructions = route.instructions;

            // Clear and populate route instructions
            document.getElementById("routeDetails").innerHTML = "<h3>Route Instructions:</h3>";
            route.instructions.forEach((instruction, index) => {
              const instructionText = document.createElement("p");
              instructionText.innerText = `${index + 1}. ${instruction.text}`;
              document.getElementById("routeDetails").appendChild(instructionText);
            });
          })
          .addTo(map);
      }
    }

    // Set up map click handler to capture start or end points
    map.on('click', function (e) {
      if (document.activeElement.id === 'startInput') {
        startPoint = e.latlng;
        document.getElementById('startInput').value = `${startPoint.lat}, ${startPoint.lng}`;
      } else if (document.activeElement.id === 'endInput') {
        endPoint = e.latlng;
        document.getElementById('endInput').value = `${endPoint.lat}, ${endPoint.lng}`;
      }

      // Calculate the route if both points are defined
      if (startPoint && endPoint) {
        calculateRoute();
      }
    });

    // Safely append input fields and route details without overwriting map
    document.body.insertAdjacentHTML('beforeend', `
  <input type="text" id="startInput" placeholder="Click to select start point" readonly>
  <input type="text" id="endInput" placeholder="Click to select end point" readonly>
  <div id="routeDetails" style="margin-top: 20px;"></div>
`);

    // Trigger to get current position
    socket.on("locationUpdate", (data) => {
      const { latitude, longitude } = data;
      console.log("Location update received in frontend:", data); // Log the received data


      // Convert base64 image back to image source
      const imgSrc = `data:image/png;base64,${data.userimage}`;

      // Add a marker with a custom icon (user's image) and popup (username)
      const icon = L.icon({
        iconUrl: imgSrc,
        iconSize: [40, 40],
        className: "user-marker",
      });
      // Update marker position and map view

      // marker.setLatLng([data.latitude, data.longitude]);
      map.setView([data.latitude, data.longitude], currentZoom);
      // Update the user marker's position
      if (userMarker) {
        userMarker.setLatLng([latitude, longitude]); // Update existing marker position
      } else {
        userMarker = L.marker([latitude, longitude], { icon: icon })
          .addTo(map)
          .bindPopup(`<b>${data.username}</b>`)
          .openPopup(); // Create marker if it doesn't exist
      }
      // } else {
      //     console.error('Invalid coordinates received');
      // }

      // Optional: Draw a route from current position to the sender's location
      const currentLatLng = map.getCenter();
      L.Routing.control({
        waypoints: [
          L.latLng(currentLatLng.lat, currentLatLng.lng),
          L.latLng(data.latitude, data.longitude),
        ],
        routeWhileDragging: true,
      }).addTo(map);

      // Add the new coordinate to the array
      coordinates.push([latitude, longitude]);


      // Update the red line and apply the bounds only if redLine is defined
      if (redLine) {
        redLine.addLatLng([latitude, longitude]);

        // Fit the map to the bounds of the red line
        map.fitBounds(redLine.getBounds());
        // map.fitBounds(window.redLine.getBounds());
      } else {
        // Create the red line if it doesn't exist
        redLine = L.polyline(coordinates, {
          color: "red",
          weight: 5,
          opacity: 0.7,
        }).addTo(map);
      }

      // Center the map on the last coordinate without changing zoom level
      map.setView([latitude, longitude], currentZoom);


    });

    // Fullscreen logic
    function requestFullscreen() {
      if (document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen();
      } else if (document.documentElement.mozRequestFullScreen) {
        // Firefox
        document.documentElement.mozRequestFullScreen();
      } else if (document.documentElement.webkitRequestFullscreen) {
        // Chrome, Safari, and Opera
        document.documentElement.webkitRequestFullscreen();
      } else if (document.documentElement.msRequestFullscreen) {
        // IE/Edge
        document.documentElement.msRequestFullscreen();
      }
    }

    // Trigger fullscreen on first touch
    window.addEventListener(
      "touchstart",
      () => {
        requestFullscreen();
      },
      { once: false }
    ); // Ensures fullscreen is only requested once

    window.addEventListener(
      "click",
      () => {
        requestFullscreen();
      },
      { once: false }
    );


    // Function to fetch route data from the server
    const fetchRouteData = async () => {
      try {
        const response = await fetch('/api/getRoute');
        const data2 = await response.json();
        console.log('Route Data:', data2); // Log the entire response data

        // Process and display route details
        displayRouteData(data2);


        // Call this function with the start and end coordinates
        // calculateRoute([data2.startLat, data2.startLng], [data2.endLat, data2.endLng]);
      } catch (error) {
        console.error('Error fetching route data:', error);
      }
    };

    // Function to display route details in the UI
    const displayRouteData = (data2) => {
      const routeDetails = document.getElementById("routeDetails");
      routeDetails.innerHTML = ""; // Clear previous data

      // Display Route Summary
      const routeInfo = document.createElement("div");
      routeInfo.innerHTML = `
    <h3>Route Summary</h3>
    <p>Distance: ${data2.route.distance} meters</p>
    <p>Duration: ${data2.route.duration} seconds</p>
  `;
      routeDetails.appendChild(routeInfo);

      // Display Waypoints
      const waypointInfo = document.createElement("div");
      waypointInfo.innerHTML = `<h4>Waypoints:</h4>`;
      data2.waypoints.forEach((waypoint, index) => {
        const wpElement = document.createElement("p");
        wpElement.innerHTML = `Waypoint ${index + 1}: [${waypoint.location[1]}, ${waypoint.location[0]}]`;
        waypointInfo.appendChild(wpElement);
      });
      routeDetails.appendChild(waypointInfo);


      console.log("Route displayed successfully");
    }



      // Example function to check for start and endpoint data from the backend
  function checkRouteData() {

 socket.on("requestRouteData", (data3) => {
     const { startLat, startLng, endLat, endLng } = data3;
      console.log("Start and end received in frontend:", data3); 
 });


    fetch('api/getStartEndPoint') // Replace with your actual backend API endpoint
      .then(response => response.json())
      .then(data3 => {
        // Check if start and endpoint data are available
        if (data3.start && data3.end) {
          // If data is available, show the button
          document.getElementById("showRouteButton").style.display = "block";
        } else {
          // Hide the button if data is not available
          document.getElementById("showRouteButton").style.display = "none";
        }
      })
      .catch(error => {
        console.error('Error fetching route data:', error);
      });
  }

  // Call checkRouteData when the page loads or as needed
  window.onload = checkRouteData;

  </script>
  </script>
</body>

</html>